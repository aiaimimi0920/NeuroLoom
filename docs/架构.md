# NeuroLoom (神织机) - SOTA 级智能体操作系统架构白皮书总纲

## 发音指南

国际音标：`/ˈnjʊəroʊ luːm/`

- **Neuro (神经)**：读作 "New-row"，代表大模型飞速运转的并发神经元
- **Loom (织机)**：读作 "Loom"，代表底层坚如磐石、不可篡改的事件溯源数据库

---

## 1. 核心设计哲学 (Core Philosophy)

- **绝对解耦 (Model-Agnostic):** 彻底摒弃"拜模型教"。大模型仅被视为"非可靠算力单元"。系统通过引入 Prompt AST 与防腐层，将核心认知与底层模型方言（JSON/XML/ChatML）绝对隔离，用��理纠偏机制（60分模型榨出90分效果）构建真正的护城河。
- **基底与不死底座 (Base & Durable Execution):** 纯 Rust 驱动的 Headless（无头）守护进程。全面拥抱 Actor 模型，追求极致的并发性能、内存安全与毫秒级状态机调度。抛弃脆弱的内存状态机，采用事件溯源 (Event Sourcing) + Actor Mesh，追求断网、断电与 API 崩溃下的完美日志重放与复活。
- **空间交互 (Spatial Flow):** CRDTs 空间流式画布与语义帧差分。抛弃线性聊天框，采用"所见即所得"的悬浮节点交互，支持静态截图与实时屏幕流。前端极简渲染（Dumb UI），逻辑全盘下沉交由后端重载（Smart Backend）。
- **网络与万维联邦 (IoA Network):** 拥抱开放网络，系统不仅是本地的超级大脑，更是开放网络的一个星际节点。基于标准的超智能体互联协议 (HAP)，支持本地 Agent 与全球第三方 Agent 的无缝竞标、任务外包、跨网通信与交易等双向互操作。
- **权限与物理真理 (Privilege & Execution as Judge):** 赋予 Agent 原生上帝模式 (Native God Mode) 与视觉操纵，获取宿主机最高操作权限及操控鼠标键盘的物理执行力。赋予执行引擎最高宿主机权限；但对于不受信代码，强制在独立微型虚拟机（Firecracker/MicroVM）中进行沙箱验证。没有幻觉，只有跑通的代码。
- **算力与进化 (Compute & Evolution):** 采用无感重试换人 (Retry & Swap) 与自适应推演，通过 Rust 异步监督树屏蔽 LLM 断流缺陷。系统享有最大算力试错特权，但代码验证成功即刻触发早停 (Early Stopping)。引入 JIT 动态铸造与 MoA 议会，系统成为创造者并在最高裁决层引入多模型混合阵列突破智商天花板。

---

## 2. 空间流式交互层 (Spatial Flow HCI Layer)

将 AI 从"聊天框里的打字员"升级为"空间计算协同伙伴"。基于 Tauri + 原生透明无边框窗口构建。

- **视觉工作区生成 (Visual Workspace Nodes):** 用户框选屏幕直接创建无边框悬浮容器。截图自动作为多模态 Vision 锚点输入，工作区成为支持任意拖入音频、PDF、代码文件作为附加输入的黑洞容器。支持多模态拖拽与 Promise Node 防等待隔离。
- **活体流与语义差分 (Live Omni-Stream & Delta-Diffing):** 突破静态锚点限制，支持将工作区绑定为实时屏幕录制流，系统实时注视屏幕提供 4D 协同。基于物理护城河，本地极其轻量的"语义帧差分感知器"仅在屏幕发生显著语义变化（如报错、跳转）时提取关键帧并发送，彻底杜绝显存核爆与 API 资源浪费。
- **预生成工作区 (The Promise Node):** 允许在左侧节点生成结束前，提前创建关联节点并输入指令。底层映射为异步期约 (Promise/Future)，完成瞬间后端唤醒，彻底消灭"等待焦虑"。
- **严格的上下文隔离:** 工作区只读取直接指向它的前置节点数据，彻底消灭全局上下文污染。
- **屏幕霸权消除:** 摒弃笨重的主控台，双击工作区可折叠为极小的"桌面贴纸 (Sticker)"，复杂的推演流统一收缩为边缘悬浮的"状态胶囊 (Capsule)"。
- **CRDTs 双轨制:** 前端 UI 基于 CRDTs 乐观更新（120fps 丝滑拖拽），语义状态（执行指令）通过防抖静默同步至后端，杜绝事件风暴。

---

## 3. 跨维度算力网关、意图解析与防腐层 (Model-Agnostic Gateway & ACL)

彻底消灭用户的 Prompt Engineering 负担，同时极度压榨 API 性能。这是保护系统纯洁性的绝对边界，解决各家大模型的"巴别塔地狱"。

- **动态人格与上下文注入器:** 后端根据意图自动匹配身份卡片 (Persona)、强制纪律与可用工具。
- **提示词抽象语法树 (Prompt AST):** 认知层内部绝不拼接字符串。所有意图、规则、上下文与历史，均被结构化为纯净的 Rust 枚举树（AST）。
- **方言翻译官 (Adapter Pattern):**
  - **Anthropic_Adapter:** 将 AST 强行重组为 XML，并将文件置顶以吃满 Prefix Caching（前缀缓存）。
  - **OpenAI_Adapter:** 将 AST 编译为严苛的 JSON Schema 与 Tool Use 格式。
  - **Ollama_Adapter:** 动态压平 AST 为 ChatML，实现断网时的无缝降级兜底。
- **前缀缓存技术 (Prefix Caching Optimization):** 组装巨型 Prompt 时实行严格的"动静分离"。系统设定、规则、HAMT 背景作为静态前缀发送以利用大模型 Cache 机制，与用户输入的动态执行层实时结合。基数树前缀缓存严格切分"绝对静态区"与"绝对动态区"，在推演树分裂中死守 90% 的缓存命中率。

---

## 4. 双擎认知引擎与 IoA 联邦网络 (Cognitive Engine & IoA Council)

系统的核心大脑与对外交流的万维口岸，不依赖单一模型智商，用算力与机制换取真理。

- **System 1 (快思考 - SOP 引擎):** 极速执行预设 DAG 工作流的高频任务，直接调用本地原生脚本。System 2 成功解决的新难题可 Auto-SOP 自动降维固化为 System 1 的管线。
- **System 2 (慢思考 - MCTS 推演与混合联邦市场):**
  - **本地竞标:** Boss 广播任务，本地 Worker 基于专长抢单。
  - **联邦星际市场:** 本地无法胜任时，系统通过 HAP 协议将任务打包广播至外部万维 Agent 网络。外部 Agent 回传报价，Local Judge 评估后建立 WebSocket 通信发送输入并取回结果，实现双向互操作。
  - **自适应蒙特卡洛树搜索 (MCTS):** 面对未知决策进行深维试错，并发探索，结合执行验证跑通立即触发早停机制。
  - **挫败指数熔断 (Frustration Index):** 植入动态挫败值，死循环超阈值时触发"模拟退火"全局重构或强制移交人类。
- **MapReduce 微观探针阵列:** 面对超大工程定位，瞬间分裂百个轻量 Agent 并发扫描源码，用并发算力暴力破解摘要压缩造成的"大海捞针"困局。
- **铁匠机制 (Blacksmith Agent):** 面临无可用 API 的冷门任务时唤醒铁匠 Agent，当场编写解析脚本，跑通验证后瞬间动态铸造并注册为新 SOP 工具。
- **MoA 混合专家议会:** 调度底层 API 矩阵，将代码合并争议等极高难度问题并发丢给 3 个异构模型背对背辩论，第 4 个模型负责归纳拍板，利用多模型互补效应合成超高智商，彻底消除单一模型偏见。

---

## 5. 质量控制与物理执行网 (QA & Security Net)

用物理真理代替模型幻觉，用模型集群碾压模型盲区。

- **执行即最高法官 (Execution Sandbox):** Critic 质检 Agent 不靠猜想报错，代码必须扔进本地沙箱真实运行（如 cargo test），真实的报错堆栈原样打回给 Worker，代码跑通了才是真理。
- **多层概率学防御:** 通过四层严密博弈过滤，将致命错误率压低至万分之五 (0.05%) 以下。
- **法庭专属微型沙箱 (MicroVM Isolation):** 针对外部 HAP 协议接收的第三方代码，强制在阅后即焚的 Firecracker 微型虚拟机或容器中验证，堵死"上帝模式"的零日漏洞。
- **异步人类介入 (HITL):** 终极物理安全阀。遇到高危 rm -rf 级别命令，Actor 状态机强制挂起休眠，等待前端确认授权后完美唤醒。

---

## 6. 终极记忆与持久化底座 (Memory & Durable Execution)

彻底解决"阿兹海默症"，实现 100% 数据精确溯源。

- **事件溯源底座:** 一切皆日志，历史对话、推演、调用均全量无损不可变地落盘写入底层 SQLite。遭遇崩溃或断电，依靠日志重放完美复活 Actor，实现绝对幂等。
- **���步快照归档:** 定期将 Actor 状态存盘，冗余事件剥离至冷区，消灭日志重放的性能黑洞。
- **HAMT 拓扑图谱与漏斗检索:** 历史记录全量落盘，后台异步提炼 20 字标签与 200 字逻辑摘要。漏斗检索实现毫秒级盲扫标签到 LLM 审判摘要，命中 UUID 提取全本并结合前缀缓存精准注入。
- **操作系统级内存分页:** RAM 永远只保留基础指令与 HAMT 索引，Agent 具备系统权限主动翻阅硬盘旧账。
- **空间拓扑记忆 (GraphRAG):** 代码库 AST 与依赖关系实例化为 SurrealDB 图数据库，赋予 Agent 空间感知力。

---

## 7. 物理基建与开放生态 (Infrastructure & Protocols)

- **重载后端容错:** Tokio 调度层引入熔断器，遇到 API 超时后端状态机自动重试，达阈值平滑转移给待命备用模型（云端 API 到本地兜底）。
- **全局令牌桶与反压路由:** 底层硬编码铁血流量控制器。海量并发请求进入优先级队列，遭遇 API 供应商 429 频控瞬间启动反压机制，强制 Actor 降频休眠免疫并发雪崩。
- **星际联邦网关 (HAP Protocol):** 基于 HTTP/WebSocket + JSON-RPC，定义全网通用的 Agent 握手、意图声明、竞标与成果交付格式，支持本地系统在网络中挂单抢单。
- **生态包管理器 (Agent Cargo):** 统一标准 MCP 接口，支持 CLI 一键拉取外部工具、Persona 卡片、SOP 模板与底座图谱。

---

## 8. 核心技术栈清单 (Tech Stack Specification)

| 领域 | 技术选型 |
|------|----------|
| 前端交互 (HCI) | Tauri + Vue3/React + Clap |
| 核心运行时 | Rust + Tokio |
| Agent 状态机与网络 | Actix + Hyper/Tungstenite |
| 通信网关 | Axum |
| 持久化底座 | SeaORM + SurrealDB |
| 终端与底层控制 | portable-pty + enigo |
| 系统观测 | tracing + opentelemetry |

---

## 9. 物理文件架构与模块划分蓝图 (Workspace Root & Crates)

构建这种超大型复杂系统的标准工程解法是 Cargo Workspace（工作区多 Crate 架构），将系统拆解为一组高内聚、低耦合的独立包，每个 Crate 只负责纯粹职责以解决合并冲突与循环依赖。

### 顶层结构设计

```
NeuroLoom/
├── Cargo.toml              # 顶级 Workspace 依赖控制中心
├── apps/
│   ├── daemon/             # [核心引擎] Headless 后台守护进程
│   └── desktop/            # [前端画布] Tauri 流式前端
└── crates/
    ├── nl_core/            # 核心原语层
    ├── nl_durable/         # 持久化执行底座
    ├── nl_llm/             # 算力与网关层
    ├── nl_memory/          # 终极记忆底座
    ├── nl_cognitive/       # 双擎认知与法庭
    ├── nl_sandbox/         # 物理执行与安全网
    ├── nl_vision/          # 视觉流
    └── nl_hap/             # 星际联邦协议
```

### 核心 Crates (器官) 深度拆解

| Crate | 职责 | 核心模块 |
|-------|------|----------|
| `nl_core` | 核心原语层，基础依赖 | `event.rs` (事件枚举)、`entity.rs` (数据结构)、`error.rs` (错误处理) |
| `nl_durable` | 持久化执行底座，崩溃复活 | `event_store.rs` (写入引擎)、`snapshot.rs` (异步快照)、`actor_mesh.rs` (生命周期管理) |
| `nl_llm` | 算力与网关层，防雪崩 | `token_bucket.rs` (流量控制)、`provider/cli_proxy.rs` (PTY通信)、`prompt/radix_tree.rs` (前缀缓存)、`fallback.rs` (降级路由) |
| `nl_memory` | 终极记忆底座 | `hamt.rs` (漏斗引擎)、`graph_rag.rs` (代码拓扑)、`archival.rs` (归档压缩) |
| `nl_cognitive` | 双擎认知与法庭 | `system1/sop_engine.rs` (DAG执行)、`system2/mcts.rs` (蒙特卡洛)、`courtroom/` (Worker/Critic/MoA)、`blacksmith.rs` (工具铸造) |
| `nl_sandbox` | 物理执行与安全网 | `god_mode/` (原生指令)、`micro_vm/firecracker.rs` (微型虚拟机验证) |
| `nl_vision` | 视觉流 | `delta_diff.rs` (语义帧差分)、`ocr.rs` |
| `nl_hap` | 星际联邦协议 | `protocol.rs` (HAP格式)、`server.rs` (WebSocket监听)、`client.rs` (跨网竞标) |

---

## 10. 实施路线图与开发启动顺序 (Bootstrapping Sequence)

开发将严格遵循从下到上、从死到活的三阶段顺序。

### Phase 1: 引擎点火与生命维持 (The Backend Engine)

**目标:** 搭建核心后端骨架，确保系统不崩溃、能容错。

- 搭建 Rust Axum + Tokio 基础骨架
- 执行 `nl_core` 与 `nl_llm`，优先实现 CLIProxy 和全局令牌桶
- 测试：并发 100 请求，确保令牌桶挡住雪崩
- 执行 `nl_durable` 实现状态机持久化与重载容错
- 测试：中断重启后 Actor 从断点继续完美溯源执行

### Phase 2: 认知与沙箱 (Cognition & Reality)

**目标:** 跑通第一个法庭闭环，实现"执行即法官"。

- 实现动态人格注入器、SOP 工作流引擎及铁匠机制
- 执行 `nl_sandbox` 与 `nl_cognitive`
- 测试：让系统写有 Bug 的代码，放进沙箱跑，Critic 审查，循环直到早停
- 部署法庭、MCTS 推演网络、HAMT 检索机制
- 实现 HAP 接口接入全球联邦大市场

### Phase 3: 空间画布 (The Spatial Canvas)

**目标:** 接上 Tauri 前端，实现空间交互。

- 建立 Tauri 前端项目
- 攻克透明截图、无边框悬浮及实时流捕获等 API 难点
- 打通 SSE 通信，跑通预生成工作区的异步唤醒与 GUI 操纵
- 启动并对接 `apps/daemon` 和 `apps/desktop`

---

## 11. 风险与对策

| 风险 | 对策 |
|------|------|
| LLM API 不稳定 | 全局令牌桶 + 熔断器 + 多级降级路由 |
| 并发雪崩 | 反压排队机制 + Actor 降频休眠 |
| 状态丢失 | 事件溯源 + 异步快照 |
| 代码执行安全 | God Mode + MicroVM 隔离 + HITL |
| 上下文爆炸 | 严格隔离 + HAMT 漏斗检索 |
| 模型幻觉 | 执行即法官 + MoA 议会 |
| 高危操作 | HITL 人类介入确认 |
| 第三方代码风险 | 阅后即焚的 MicroVM 沙箱 |
| 单一模型偏见 | MoA 多模型议会背对背辩论 |
| 推演死循环 | 挫败指数熔断 + 模拟退火 |

---

## 12. 关键设计决策

### 为什么选择 Actor Mesh？
- 天然支持分布式并发
- 状态隔离，故障不扩散
- 配合事件溯源实现"不死之身"

### 为什么选择事件溯源 (Event Sourcing)？
- 100% 数据可追溯
- 支持时间旅行调试
- 天然适配 Actor 模型的状态恢复

### 为什么引入 Prompt AST？
- 彻底解耦核心认知与模型方言
- 支持多模型无缝切换
- 为前缀缓存优化提供结构化基础

### 为什么选择 Rust？
- 内存安全无 GC
- 零成本抽象
- 优秀的异步生态
- 适合系统级编程

### 为什么选择 Tauri？
- 轻量级 (相比 Electron)
- 原生性能
- 安全的 IPC 机制
- 支持透明无边框窗口

---

*本架构文档作为 NeuroLoom 项目的最高开发宪法，全面冻结，随时可进入实质性代码开发阶段。*
